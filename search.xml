<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android PopupWindow怎么合理控制弹出位置]]></title>
    <url>%2F2018%2F08%2F26%2FAndroid-PopupWindow%E6%80%8E%E4%B9%88%E5%90%88%E7%90%86%E6%8E%A7%E5%88%B6%E5%BC%B9%E5%87%BA%E4%BD%8D%E7%BD%AE%EF%BC%88showAtLocation%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说到PopupWindow，应该都会有种熟悉的感觉，使用起来也很简单 1234567891011121314// 一个自定义的布局，作为显示的内容Context context = null; // 真实环境中要赋值int layoutId = 0; // 布局IDView contentView = LayoutInflater.from(context).inflate(layoutId, null); final PopupWindow popupWindow = new PopupWindow(contentView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, true);popupWindow.setTouchable(true);// 如果不设置PopupWindow的背景，有些版本就会出现一个问题：无论是点击外部区域还是Back键都无法dismiss弹框// 这里单独写一篇文章来分析popupWindow.setBackgroundDrawable(new ColorDrawable());// 设置好参数之后再showpopupWindow.showAsDropDown(contentView); 如果创建PopupWindow的时候没有指定高宽，那么showAsDropDown默认只会向下弹出显示，这种情况有个最明显的缺点就是：弹窗口可能被屏幕截断，显示不全，所以需要使用到另外一个方法showAtLocation,这个的坐标是相对于整个屏幕的，所以需要我们自己计算位置。 如下图所示，我们可以根据屏幕左上角的坐标A，屏幕高宽，点击View的左上角的坐标C，点击View的大小以及PopupWindow布局的大小计算出PopupWindow的显示位置B 计算方法源码如下： 12345678910111213141516171819202122232425262728293031/** * 计算出来的位置，y方向就在anchorView的上面和下面对齐显示，x方向就是与屏幕右边对齐显示 * 如果anchorView的位置有变化，就可以适当自己额外加入偏移来修正 * @param anchorView 呼出window的view * @param contentView window的内容布局 * @return window显示的左上角的xOff,yOff坐标 */private static int[] calculatePopWindowPos(final View anchorView, final View contentView) &#123; final int windowPos[] = new int[2]; final int anchorLoc[] = new int[2]; // 获取锚点View在屏幕上的左上角坐标位置 anchorView.getLocationOnScreen(anchorLoc); final int anchorHeight = anchorView.getHeight(); // 获取屏幕的高宽 final int screenHeight = ScreenUtils.getScreenHeight(anchorView.getContext()); final int screenWidth = ScreenUtils.getScreenWidth(anchorView.getContext()); contentView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED); // 计算contentView的高宽 final int windowHeight = contentView.getMeasuredHeight(); final int windowWidth = contentView.getMeasuredWidth(); // 判断需要向上弹出还是向下弹出显示 final boolean isNeedShowUp = (screenHeight - anchorLoc[1] - anchorHeight &lt; windowHeight); if (isNeedShowUp) &#123; windowPos[0] = screenWidth - windowWidth; windowPos[1] = anchorLoc[1] - windowHeight; &#125; else &#123; windowPos[0] = screenWidth - windowWidth; windowPos[1] = anchorLoc[1] + anchorHeight; &#125; return windowPos;&#125; 接下来调用showAtLoaction显示： 123456View windowContentViewRoot = 我们要设置给PopupWindow进行显示的Viewint windowPos[] = calculatePopWindowPos(view, windowContentViewRoot);int xOff = 20；// 可以自己调整偏移windowPos[0] -= xOff;popupwindow.showAtLocation(view, Gravity.TOP | Gravity.START, windowPos[0], windowPos[1]);// windowContentViewRoot是根布局View 上面的例子只是提供了一种计算方式，在实际开发中可以根据需求自己计算，比如anchorView在左边的情况，在中间的情况，可以根据实际需求写一个弹出位置能够自适应的PopupWindow。 补充上获取屏幕高宽的代码ScreenUtils.java： 123456789101112/** * 获取屏幕高度(px) */public static int getScreenHeight(Context context) &#123; return context.getResources().getDisplayMetrics().heightPixels;&#125;/** * 获取屏幕宽度(px) */public static int getScreenWidth(Context context) &#123; return context.getResources().getDisplayMetrics().widthPixels;&#125; Demo截图展示： 看完觉得有用记得点击推荐支持一下，谢谢 Demo下载地址：https://github.com/PopFisher/SmartPopupWindow]]></content>
      <tags>
        <tag>Android PopupWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidSwitch控件修改样式]]></title>
    <url>%2F2018%2F05%2F22%2FAndroidSwitch%E6%8E%A7%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android中自带的Switch控件在很多时候总觉得和整体系统风格不符，很多时候，自定义Switch是一种方法。 但其实不用这么麻烦，安卓自带的Switch通过修改一些属性，也可以达到和自定义Switch差不多的一个效果。 个人感觉，Switch的属性设置和其他控件还是有挺大区别的。因此，写下此文，方便有需要的同学参考。 先上效果图： 以上便是修改后效果 与 原生Switch的效果对比。代码在文章底部给出 实现方式： 1.底部滑动条，在开关打开状态为绿色，开关关闭状态为灰色在 res/drawable 文件夹下面，写两个滑动条的底图 ，通过一个选择器selector进行控制。 gray_track.xml ：非打开状态，灰色的底图 123456789101112&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;shapexmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!--高度30此处设置宽度无效--&gt; &lt;size android:height="30dp"/&gt; &lt;!--圆角弧度15--&gt; &lt;corners android:radius="15dp"/&gt; &lt;!--变化率定义从左到右的颜色不变--&gt; &lt;gradient android:endColor="#888888" android:startColor="#888888"/&gt;&lt;/shape&gt; green_track.xml：打开状态下，绿色的底图。 1234567891011&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;shapexmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--高度40--&gt; &lt;sizeandroid:height="30dp"/&gt; &lt;!--圆角弧度20--&gt; &lt;cornersandroid:radius="15dp"/&gt; &lt;!--变化率--&gt; &lt;gradient android:endColor="#33da33" android:startColor="#33da33"/&gt;&lt;/shape&gt; 选择器 track.xml 用于控制Switch不同状态下，滑动条的底图 123456&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;!--底层下滑条的样式选择器，可控制Switch在不同状态下，底下下滑条的颜色--&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_checked="true" android:drawable="@drawable/green_track"/&gt; &lt;item android:drawable="@drawable/gray_track"/&gt;&lt;/selector&gt; 2. 滑动按钮：底色我用的接近白色的淡灰色，打开时，边上的一圈线条为灰色，关闭时，边上的一圈线条为绿色实现方式和底部滑动一致 gray_thumb.xml :关闭状态，按钮边上一圈颜色为深灰色 1234567891011121314&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;shapexmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!--高度40--&gt; &lt;sizeandroid:height="40dp"android:width="40dp"/&gt; &lt;!--圆角弧度20--&gt; &lt;cornersandroid:radius="20dp"/&gt; &lt;!--变化率--&gt; &lt;gradient android:endColor="#eeeeee" android:startColor="#eeeeee"/&gt; &lt;strokeandroid:width="1dp" android:color="#666666"/&gt;&lt;/shape&gt; green_thumb.xml : 打开状态，按钮边上一圈的颜色为绿色 1234567891011121314&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;shapexmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;!--高度40--&gt; &lt;size android:height="40dp" android:width="40dp"/&gt; &lt;!--圆角弧度20--&gt; &lt;corners android:radius="20dp"/&gt; &lt;!--变化率--&gt; &lt;gradient android:endColor="#eeeeee" android:startColor="#eeeeee"/&gt; &lt;stroke android:width="1dp" android:color="#33da33"/&gt;&lt;/shape&gt; 选择器 thumb.xml 用于控制Switch不同状态下，按钮的显示状态 123456&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;!--按钮的选择器，可以设置按钮在不同状态下的时候，按钮不同的颜色--&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_checked="true" android:drawable="@drawable/green_thumb"/&gt; &lt;item android:drawable="@drawable/gray_thumb"/&gt;&lt;/selector&gt; 3. 将以上选择器设置给Switch，就好了界面 activity_main.xml 12345678910111213141516171819&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Switch android:layout_width="wrap_content" android:layout_height="wrap_content" android:switchMinWidth="20dp" android:textOn="" android:textOff="" android:thumb="@drawable/thumb" android:track="@drawable/track"/&gt; &lt;!--用于对比使用的不设置任何属性的Switch--&gt; &lt;Switch android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 4.高度，宽度的设置细心的同学会发现，修改 android:layout_width ， android:layout_height 这两个属性，并不会实际修改Switch的大小 设置大了，边上会出现空白部分，设置小了，Switch显示不全。 实际设置高度方法： 上面定义滑动条和按钮底图的地方相信大家都注意到， 这行代码， 修改 green_track.xml,gray_track.xml 中的高度，即可修改高度（修改green_thumb.xml gray_thumb.xml 中的高度貌似无效）。 实际修改宽度的方法： （1）修改滑动按钮的宽度：滑动按钮的宽度和按钮上的文字有关， 想要按钮变长，在按钮显示的文字上添加几个空字符串即可，想要按钮变短的话，减少按钮上显示的字即可（修改按钮上字体大小也可以试试） Switch的属性 12android:textOn=" "android:textOff=" " （2）修改按钮 打开，关闭 两种状态之间滑动距离（貌似小到一定程度，再改小就无效了） Switch的属性 android:switchMinWidth=&quot;20dp&quot; 通过以上的设置，相信能满足大部分实际使用的需求了，希望对大家有帮助。 相信源代码才是大家最关注的吧，哈哈，我也是！下载地址： http://download.csdn.net/detail/qq_34763699/9751234 百度网盘：http://pan.baidu.com/s/1slp1CZV]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArcGIS Runtime中坐标的转换]]></title>
    <url>%2F2018%2F05%2F12%2FArcGIS-Runtime%E4%B8%AD%E5%9D%90%E6%A0%87%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[【原文链接：https://blog.csdn.net/bit_kaki/article/details/76252181】 在我们的GIS应用项目里，常常遇见坐标转换的问题。最常见的就是WGS84坐标转其他坐标系，原因是WGS84坐标系是目前GPS数据采集所用的坐标系，而我国实际生产项目里常用的地图却是北京54坐标系，西安80坐标系以及中国大地2000坐标系等。所以当我们用设备采集到GPS经纬度以后，需要将其进行坐标转换才可以正确显示到我们使用的地图上。 对于坐标转换，有一种高精度而且任何时候都可以采用的方法是七参数坐标转换法，对于这种方法，我在之前一篇博客进行了详细的说明，地址是：http://blog.csdn.net/bit_kaki/article/details/52733429 。 但是在实际情况下，我们不一定拥有七参数，而且对采集的精度要求也并不那么高。在这个时候，其实ArcGIS for Android的库里已经给我们封装了个一个方法，我们可以直接调用就可以。这个方法就是123public static Geometry project(Geometry geometry, SpatialReference inputSR, SpatialReference outputSR) &#123; return GeometryEngineCore.project(geometry, inputSR, outputSR);&#125; 这个方法里三个参数分别是需要转换矢量对象（点、线、面），输入对象的空间参考坐标系，输出对象的空间参考坐标系。最后得到一个转换后的矢量对象。 比如我们程序里的MapView参数为mMapView，那么要将一个点从WGS84坐标系转换为MapView上加载图层的坐标系，我们只需要：1Point point=(Point) GeometryEngine.project(wgs, SpatialReference.create(4326),mMapView.getSpatialReference()); 其中wgs是一个WGS84坐标系上的点的坐标，SpatialReference.create（4326）指的是输入点的空间坐标系mMapView.getSpatialReference（）是mMapView目前加载图层所使用的坐标系。 方法挺简单的，但是对于这个方法我们可以稍作一下研究里面SpatialReference参数的意义。 SpatialReference在指的ArcGIS里的地理坐标系对象，里面主要包含了五个参数： WKID：空间参考系统编号。 WKT：空间参考系统文本。 Unit：空间参考系统单位。 Tolerance：系统容差。 GCS：地理坐标系。 这五个参数里第一个或者第二个是必须存在的，根据编号或者文本就可以获取到对应的空间坐标系。其中通过WKID来建立地理坐标系对象是最常见的，WKID，全称是Well Known ID，即ArcGIS对众多的空间坐标系进行的编号。只要我们知道空间参考坐标系所对应的编号，就可以通过这个编号获取到该控件参考坐标系。比如上个例子用到的SpatialReference.create（4326），4326对应的是WGS84坐标系，所以SpatialReference.create（4326）就是WGS85地理坐标系对象了。通过阅读Esri官方SDK文档，可以知道投影坐标枚举esriSRProjCSType包含1442个WKID,esriSRProjCS4Type包含1224个WKID。在这里将国内常用坐标系统的WKID整理如下： 类别 WKID 名称 地理坐标 4214 GCS_Beijing_1954 地理坐标 4326 GCS_WGS_1984 地理坐标 4490 GCS_China_Geodetic_Coordinate_System_2000 地理坐标 4555 GCS_New_Beijing 地理坐标 4610 GCS_Xian_1980 投影坐标 2327 Xian_1980_GK_Zone_13 投影坐标 2328 Xian_1980_GK_Zone_14 投影坐标 2329 Xian_1980_GK_Zone_15 投影坐标 2330 Xian_1980_GK_Zone_16 投影坐标 2331 Xian_1980_GK_Zone_17 投影坐标 2332 Xian_1980_GK_Zone_18 投影坐标 2333 Xian_1980_GK_Zone_19 投影坐标 2334 Xian_1980_GK_Zone_20 投影坐标 2335 Xian_1980_GK_Zone_21 投影坐标 2336 Xian_1980_GK_Zone_22 投影坐标 2337 Xian_1980_GK_Zone_23 投影坐标 2338 Xian_1980_GK_CM_75E 投影坐标 2339 Xian_1980_GK_CM_81E 投影坐标 2340 Xian_1980_GK_CM_87E 投影坐标 2341 Xian_1980_GK_CM_93E 投影坐标 2342 Xian_1980_GK_CM_99E 投影坐标 2343 Xian_1980_GK_CM_105E 投影坐标 2344 Xian_1980_GK_CM_111E 投影坐标 2345 Xian_1980_GK_CM_117E 投影坐标 2346 Xian_1980_GK_CM_123E 投影坐标 2347 Xian_1980_GK_CM_129E 投影坐标 2348 Xian_1980_GK_CM_135E 投影坐标 2349 Xian_1980_3_Degree_GK_Zone_25 投影坐标 2350 Xian_1980_3_Degree_GK_Zone_26 投影坐标 2351 Xian_1980_3_Degree_GK_Zone_27 投影坐标 2352 Xian_1980_3_Degree_GK_Zone_28 投影坐标 2353 Xian_1980_3_Degree_GK_Zone_29 投影坐标 2354 Xian_1980_3_Degree_GK_Zone_30 投影坐标 2355 Xian_1980_3_Degree_GK_Zone_31 投影坐标 2356 Xian_1980_3_Degree_GK_Zone_32 投影坐标 2357 Xian_1980_3_Degree_GK_Zone_33 投影坐标 2358 Xian_1980_3_Degree_GK_Zone_34 投影坐标 2359 Xian_1980_3_Degree_GK_Zone_35 投影坐标 2360 Xian_1980_3_Degree_GK_Zone_36 投影坐标 2361 Xian_1980_3_Degree_GK_Zone_37 投影坐标 2362 Xian_1980_3_Degree_GK_Zone_38 投影坐标 2363 Xian_1980_3_Degree_GK_Zone_39 投影坐标 2364 Xian_1980_3_Degree_GK_Zone_40 投影坐标 2365 Xian_1980_3_Degree_GK_Zone_41 投影坐标 2366 Xian_1980_3_Degree_GK_Zone_42 投影坐标 2367 Xian_1980_3_Degree_GK_Zone_43 投影坐标 2368 Xian_1980_3_Degree_GK_Zone_44 投影坐标 2369 Xian_1980_3_Degree_GK_Zone_45 投影坐标 2370 Xian_1980_3_Degree_GK_CM_75E 投影坐标 2371 Xian_1980_3_Degree_GK_CM_78E 投影坐标 2372 Xian_1980_3_Degree_GK_CM_81E 投影坐标 2373 Xian_1980_3_Degree_GK_CM_84E 投影坐标 2374 Xian_1980_3_Degree_GK_CM_87E 投影坐标 2375 Xian_1980_3_Degree_GK_CM_90E 投影坐标 2376 Xian_1980_3_Degree_GK_CM_93E 投影坐标 2377 ian_1980_3_Degree_GK_CM_96E 投影坐标 2378 Xian_1980_3_Degree_GK_CM_99E 投影坐标 2379 Xian_1980_3_Degree_GK_CM_102E 投影坐标 2380 Xian_1980_3_Degree_GK_CM_105E 投影坐标 2381 Xian_1980_3_Degree_GK_CM_108E 投影坐标 2382 Xian_1980_3_Degree_GK_CM_111E 投影坐标 2383 Xian_1980_3_Degree_GK_CM_114E 投影坐标 2384 Xian_1980_3_Degree_GK_CM_117E 投影坐标 2385 Xian_1980_3_Degree_GK_CM_120E 投影坐标 2386 Xian_1980_3_Degree_GK_CM_123E 投影坐标 2387 Xian_1980_3_Degree_GK_CM_126E 投影坐标 2388 Xian_1980_3_Degree_GK_CM_129E 投影坐标 2389 Xian_1980_3_Degree_GK_CM_132E 投影坐标 2390 Xian_1980_3_Degree_GK_CM_135E 投影坐标 2401 Beijing_1954_3_Degree_GK_Zone_25 投影坐标 2402 Beijing_1954_3_Degree_GK_Zone_26 投影坐标 2403 Beijing_1954_3_Degree_GK_Zone_27 投影坐标 2404 Beijing_1954_3_Degree_GK_Zone_28 投影坐标 2405 Beijing_1954_3_Degree_GK_Zone_29 投影坐标 2406 Beijing_1954_3_Degree_GK_Zone_30 投影坐标 2407 Beijing_1954_3_Degree_GK_Zone_31 投影坐标 2408 Beijing_1954_3_Degree_GK_Zone_32 投影坐标 2409 Beijing_1954_3_Degree_GK_Zone_33 投影坐标 2410 Beijing_1954_3_Degree_GK_Zone_34 投影坐标 2411 Beijing_1954_3_Degree_GK_Zone_35 投影坐标 2412 Beijing_1954_3_Degree_GK_Zone_36 投影坐标 2413 Beijing_1954_3_Degree_GK_Zone_37 投影坐标 2414 Beijing_1954_3_Degree_GK_Zone_38 投影坐标 2415 Beijing_1954_3_Degree_GK_Zone_39 投影坐标 2416 Beijing_1954_3_Degree_GK_Zone_40 投影坐标 2417 Beijing_1954_3_Degree_GK_Zone_41 投影坐标 2418 Beijing_1954_3_Degree_GK_Zone_42 投影坐标 2419 Beijing_1954_3_Degree_GK_Zone_43 投影坐标 2420 Beijing_1954_3_Degree_GK_Zone_44 投影坐标 2421 Beijing_1954_3_Degree_GK_Zone_45 投影坐标 2422 Beijing_1954_3_Degree_GK_CM_75E 投影坐标 2423 Beijing_1954_3_Degree_GK_CM_78E 投影坐标 2424 Beijing_1954_3_Degree_GK_CM_81E 投影坐标 2425 Beijing_1954_3_Degree_GK_CM_84E 投影坐标 2426 Beijing_1954_3_Degree_GK_CM_87E 投影坐标 2427 Beijing_1954_3_Degree_GK_CM_90E 投影坐标 2428 Beijing_1954_3_Degree_GK_CM_93E 投影坐标 2429 Beijing_1954_3_Degree_GK_CM_96E 投影坐标 2430 Beijing_1954_3_Degree_GK_CM_99E 投影坐标 2431 Beijing_1954_3_Degree_GK_CM_102E 投影坐标 2432 Beijing_1954_3_Degree_GK_CM_105E 投影坐标 2433 Beijing_1954_3_Degree_GK_CM_108E 投影坐标 2434 Beijing_1954_3_Degree_GK_CM_111E 投影坐标 2435 Beijing_1954_3_Degree_GK_CM_114E 投影坐标 2436 Beijing_1954_3_Degree_GK_CM_117E 投影坐标 2437 Beijing_1954_3_Degree_GK_CM_120E 投影坐标 2438 Beijing_1954_3_Degree_GK_CM_123E 投影坐标 2439 Beijing_1954_3_Degree_GK_CM_126E 投影坐标 2440 Beijing_1954_3_Degree_GK_CM_129E 投影坐标 2441 Beijing_1954_3_Degree_GK_CM_132E 投影坐标 2442 Beijing_1954_3_Degree_GK_CM_135E 投影坐标 3395 WGS_1984_World_Mercator 投影坐标 4491 CGCS2000_GK_Zone_13 投影坐标 4492 CGCS2000_GK_Zone_14 投影坐标 4493 CGCS2000_GK_Zone_15 投影坐标 4494 CGCS2000_GK_Zone_16 投影坐标 4495 CGCS2000_GK_Zone_17 投影坐标 4496 CGCS2000_GK_Zone_18 投影坐标 4497 CGCS2000_GK_Zone_19 投影坐标 4498 CGCS2000_GK_Zone_20 投影坐标 4499 CGCS2000_GK_Zone_21 投影坐标 4500 CGCS2000_GK_Zone_22 投影坐标 4501 CGCS2000_GK_Zone_23 投影坐标 4502 CGCS2000_GK_CM_75E 投影坐标 4503 CGCS2000_GK_CM_81E 投影坐标 4504 CGCS2000_GK_CM_87E 投影坐标 4505 CGCS2000_GK_CM_93E 投影坐标 4506 CGCS2000_GK_CM_99E 投影坐标 4507 CGCS2000_GK_CM_105E 投影坐标 4508 CGCS2000_GK_CM_111E 投影坐标 4509 CGCS2000_GK_CM_117E 投影坐标 4510 CGCS2000_GK_CM_123E 投影坐标 4511 CGCS2000_GK_CM_129E 投影坐标 4512 CGCS2000_GK_CM_135E 投影坐标 4513 CGCS2000_3_Degree_GK_Zone_25 投影坐标 4514 CGCS2000_3_Degree_GK_Zone_26 投影坐标 4515 CGCS2000_3_Degree_GK_Zone_27 投影坐标 4516 CGCS2000_3_Degree_GK_Zone_28 投影坐标 4517 CGCS2000_3_Degree_GK_Zone_29 投影坐标 4518 CGCS2000_3_Degree_GK_Zone_30 投影坐标 4519 CGCS2000_3_Degree_GK_Zone_31 投影坐标 4520 CGCS2000_3_Degree_GK_Zone_32 投影坐标 4521 CGCS2000_3_Degree_GK_Zone_33 投影坐标 4522 CGCS2000_3_Degree_GK_Zone_34 投影坐标 4523 CGCS2000_3_Degree_GK_Zone_35 投影坐标 4524 CGCS2000_3_Degree_GK_Zone_36 投影坐标 4525 CGCS2000_3_Degree_GK_Zone_37 投影坐标 4526 CGCS2000_3_Degree_GK_Zone_38 投影坐标 4527 CGCS2000_3_Degree_GK_Zone_39 投影坐标 4528 CGCS2000_3_Degree_GK_Zone_40 投影坐标 4529 CGCS2000_3_Degree_GK_Zone_41 投影坐标 4530 CGCS2000_3_Degree_GK_Zone_42 投影坐标 4531 CGCS2000_3_Degree_GK_Zone_43 投影坐标 4532 CGCS2000_3_Degree_GK_Zone_44 投影坐标 4533 CGCS2000_3_Degree_GK_Zone_45 投影坐标 4534 CGCS2000_3_Degree_GK_CM_75E 投影坐标 4535 CGCS2000_3_Degree_GK_CM_78E 投影坐标 4536 CGCS2000_3_Degree_GK_CM_81E 投影坐标 4537 CGCS2000_3_Degree_GK_CM_84E 投影坐标 4538 CGCS2000_3_Degree_GK_CM_87E 投影坐标 4539 CGCS2000_3_Degree_GK_CM_90E 投影坐标 4540 CGCS2000_3_Degree_GK_CM_93E 投影坐标 4541 CGCS2000_3_Degree_GK_CM_96E 投影坐标 4542 CGCS2000_3_Degree_GK_CM_99E 投影坐标 4543 CGCS2000_3_Degree_GK_CM_102E 投影坐标 4544 CGCS2000_3_Degree_GK_CM_105E 投影坐标 4545 CGCS2000_3_Degree_GK_CM_108E 投影坐标 4546 CGCS2000_3_Degree_GK_CM_111E 投影坐标 4547 CGCS2000_3_Degree_GK_CM_114E 投影坐标 4548 CGCS2000_3_Degree_GK_CM_117E 投影坐标 4549 CGCS2000_3_Degree_GK_CM_120E 投影坐标 4550 CGCS2000_3_Degree_GK_CM_123E 投影坐标 4551 CGCS2000_3_Degree_GK_CM_126E 投影坐标 4552 CGCS2000_3_Degree_GK_CM_129E 投影坐标 4553 CGCS2000_3_Degree_GK_CM_132E 投影坐标 4554 CGCS2000_3_Degree_GK_CM_135E 投影坐标 4568 New_Beijing_Gauss_Kruger_Zone_13 投影坐标 4569 New_Beijing_Gauss_Kruger_Zone_14 投影坐标 4570 New_Beijing_Gauss_Kruger_Zone_15 投影坐标 4571 New_Beijing_Gauss_Kruger_Zone_16 投影坐标 4572 New_Beijing_Gauss_Kruger_Zone_17 投影坐标 4573 New_Beijing_Gauss_Kruger_Zone_18 投影坐标 4574 New_Beijing_Gauss_Kruger_Zone_19 投影坐标 4575 New_Beijing_Gauss_Kruger_Zone_20 投影坐标 4576 New_Beijing_Gauss_Kruger_Zone_21 投影坐标 4577 New_Beijing_Gauss_Kruger_Zone_22 投影坐标 4578 New_Beijing_Gauss_Kruger_Zone_23 投影坐标 4579 New_Beijing_Gauss_Kruger_CM_75E 投影坐标 4580 New_Beijing_Gauss_Kruger_CM_81E 投影坐标 4581 New_Beijing_Gauss_Kruger_CM_87E 投影坐标 4582 New_Beijing_Gauss_Kruger_CM_93E 投影坐标 4583 New_Beijing_Gauss_Kruger_CM_99E 投影坐标 4584 New_Beijing_Gauss_Kruger_CM_105E 投影坐标 4585 New_Beijing_Gauss_Kruger_CM_111E 投影坐标 4586 New_Beijing_Gauss_Kruger_CM_117E 投影坐标 4587 New_Beijing_Gauss_Kruger_CM_123E 投影坐标 4588 New_Beijing_Gauss_Kruger_CM_129E 投影坐标 4589 New_Beijing_Gauss_Kruger_CM_135E 投影坐标 4652 New_Beijing_3_Degree_Gauss_Kruger_Zone_25 投影坐标 4653 New_Beijing_3_Degree_Gauss_Kruger_Zone_26 投影坐标 4654 New_Beijing_3_Degree_Gauss_Kruger_Zone_27 投影坐标 4655 New_Beijing_3_Degree_Gauss_Kruger_Zone_28 投影坐标 4656 New_Beijing_3_Degree_Gauss_Kruger_Zone_29 投影坐标 4766 New_Beijing_3_Degree_Gauss_Kruger_Zone_30 投影坐标 4767 New_Beijing_3_Degree_Gauss_Kruger_Zone_31 投影坐标 4768 New_Beijing_3_Degree_Gauss_Kruger_Zone_32 投影坐标 4769 New_Beijing_3_Degree_Gauss_Kruger_Zone_33 投影坐标 4770 New_Beijing_3_Degree_Gauss_Kruger_Zone_34 投影坐标 4771 New_Beijing_3_Degree_Gauss_Kruger_Zone_35 投影坐标 4772 New_Beijing_3_Degree_Gauss_Kruger_Zone_36 投影坐标 4773 New_Beijing_3_Degree_Gauss_Kruger_Zone_37 投影坐标 4774 New_Beijing_3_Degree_Gauss_Kruger_Zone_38 投影坐标 4775 New_Beijing_3_Degree_Gauss_Kruger_Zone_39 投影坐标 4776 New_Beijing_3_Degree_Gauss_Kruger_Zone_40 投影坐标 4777 New_Beijing_3_Degree_Gauss_Kruger_Zone_41 投影坐标 4778 New_Beijing_3_Degree_Gauss_Kruger_Zone_42 投影坐标 4779 New_Beijing_3_Degree_Gauss_Kruger_Zone_43 投影坐标 4780 New_Beijing_3_Degree_Gauss_Kruger_Zone_44 投影坐标 4781 New_Beijing_3_Degree_Gauss_Kruger_Zone_45 投影坐标 4782 New_Beijing_3_Degree_Gauss_Kruger_CM_75E 投影坐标 4783 New_Beijing_3_Degree_Gauss_Kruger_CM_78E 投影坐标 4784 New_Beijing_3_Degree_Gauss_Kruger_CM_81E 投影坐标 4785 New_Beijing_3_Degree_Gauss_Kruger_CM_84E 投影坐标 4786 New_Beijing_3_Degree_Gauss_Kruger_CM_87E 投影坐标 4787 New_Beijing_3_Degree_Gauss_Kruger_CM_90E 投影坐标 4788 New_Beijing_3_Degree_Gauss_Kruger_CM_93E 投影坐标 4789 New_Beijing_3_Degree_Gauss_Kruger_CM_96E 投影坐标 4790 New_Beijing_3_Degree_Gauss_Kruger_CM_99E 投影坐标 4791 New_Beijing_3_Degree_Gauss_Kruger_CM_102E 投影坐标 4792 New_Beijing_3_Degree_Gauss_Kruger_CM_105E 投影坐标 4793 New_Beijing_3_Degree_Gauss_Kruger_CM_108E 投影坐标 4794 New_Beijing_3_Degree_Gauss_Kruger_CM_111E 投影坐标 4795 New_Beijing_3_Degree_Gauss_Kruger_CM_114E 投影坐标 4796 New_Beijing_3_Degree_Gauss_Kruger_CM_117E 投影坐标 4797 New_Beijing_3_Degree_Gauss_Kruger_CM_120E 投影坐标 4798 New_Beijing_3_Degree_Gauss_Kruger_CM_123E 投影坐标 4799 New_Beijing_3_Degree_Gauss_Kruger_CM_126E 投影坐标 4800 New_Beijing_3_Degree_Gauss_Kruger_CM_129E 投影坐标 4822 New_Beijing_3_Degree_Gauss_Kruger_CM_135E 以后需要坐标转换，直接查询这个表就可以了。 参考文章：http://www.cnblogs.com/liweis/p/5951032.htmlhttp://blog.sina.com.cn/s/blog_80a9926b0101g0e0.htmlhttp://blog.csdn.net/zhouxuguang236/article/details/10752199]]></content>
      <categories>
        <category>Android</category>
        <category>ArcGIS Runtime</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ArcGIS Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到 Hexo! 来发布你的第一篇博客吧. 查看 文档 以获取更多信息. 如果你在使用Hexo的过程中遇到任何问题, 你可以来 troubleshooting 寻找答案或者在 GitHub上提问. 快速开始创建新博客1$ hexo new "My New Post" 更多信息: Writing 运行服务1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 推送到远程站点1$ hexo deploy 更多信息: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派：通过红外控制蓝牙音乐播放]]></title>
    <url>%2F2016%2F11%2F19%2FRaspberry-IR-COntrol-BluetoothMusic%2F</url>
    <content type="text"><![CDATA[【参考资料】树莓派学习笔记——UART使用linux下串口调试（只用shell） 本文的目的是在上一篇文章（树莓派红外遥控测试）的基础上，用红外控制树莓派，向蓝牙模块发送串口指令，进而控制蓝牙模块的音乐播放。 【准备材料】 树莓派一个 红外接收器（本文用的是VS1838B） 红外遥控器 蓝牙模块（BK8000L） 杜邦线若干条 【详细步骤】 1.将所有配件连接起来这是上次用到的遥控器和红外接收器（VS1838B）：还有本次用到的蓝牙模块（BK8000L）：树莓派引脚编号参考：将蓝牙模块的串口接到树莓派的串口上面，TX接RX，RX接TX，VCC接3.3V，GND接GND，所有配件连接起来后：2.修改树莓派系统文件因为树莓派的串口默认用来远程登录用，所有先修改系统文件，将其功能恢复。【1】修改 /boot/cmdline.txt执行1sudo leafpad /boot/cmdline.txt 删除加粗部分：dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait最终变为:1dwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait 网上还说要修改 /etc/inittab，不过在我的系统里面没有这个文件，不知道为什么。网上说要注释掉最后一行内容：T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100 最后重启树莓派。 2.测试蓝牙模块串口通信根据模块资料：12345678控制指令格式：AT+&lt;CMD&gt;[&lt;param&gt;]\r\n数据反馈格式：&lt;IND&gt;[&lt;param&gt;]\r\n说明：控制指令是控制主机给蓝牙的控制命令，以“AT+”开始后面紧跟&lt;CMD&gt;控制指令，如果该指令带参数，则紧跟指令后继续传输&lt;param&gt;参数，最后以”\r\n”结束。数据反馈是蓝牙把各种状态和数据信息反馈给主机，&lt;IND&gt;是反馈指令，如果需要带参数，则紧跟&lt;IND&gt;之后继续传输&lt;param&gt;参数。注意： \r\n：字符型为 换行，十六进制为 0x0D ，0x0A。 树莓派上串口通信可以用Python的serial模块，这里只做测试用，为了方便就用shell直接发送命令了。树莓派中打开终端，输入：123# echo -e 可以发送回车等特殊字符echo -e &quot;AT+MN\r&quot; &gt;/dev/ttyAMA0cat /dev/ttyAMA0 第一条指令为向蓝牙模块发送串口指令“AT+MN\r”，即请求蓝牙模块的名称。“ttyAMA0”为树莓派的串口设备名字第二条指令为接收来自串口设备“ttyAMA0”的数据，例如上述命令执行完毕后，如果顺利的话，终端会返回蓝牙模块的名字：1NA: BK8000L 表示串口通信没有问题。 3.实现红外控制蓝牙模块要想实现对应功能，只需要通过树莓派向蓝牙模块发送串口指令即可，如要向实现播放/暂停功能，需要通过串口想蓝牙模块发送：12AT+MA\r #\r为换行符 在上篇文章（树莓派红外遥控测试）中已经实现了红外控制树莓派执行相应的命令，其中按键与对应命令的配置文件存储在 /home/pi/.lircrc 文件中。所以这次打开这个文件并编辑1sudo leafpad /home/pi/.lircrc 添加如下代码并保存：12345678910111213141516171819202122232425begin prog = irexec button = KEY_PLAY config = sudo echo -e &quot;AT+MA\r&quot; &gt; /dev/ttyAMA0; cat /dev/ttyAMA0endbegin prog = irexec button = KEY_NEXT config = sudo echo -e &quot;AT+MD\r&quot; &gt; /dev/ttyAMA0; cat /dev/ttyAMA0endbegin prog = irexec button = KEY_PREVIOUS config = sudo echo -e &quot;AT+ME\r&quot; &gt; /dev/ttyAMA0; cat /dev/ttyAMA0endbegin prog = irexec button = KEY_VOLUMEUP config = sudo echo -e &quot;AT+CK\r&quot; &gt; /dev/ttyAMA0; cat /dev/ttyAMA0endbegin prog = irexec button = KEY_VOLUMEDOWN config = sudo echo -e &quot;AT+CL\r&quot; &gt; /dev/ttyAMA0; cat /dev/ttyAMA0end 编辑完毕后保存退出，重启红外控制服务，然后执行 irexec：12sudo /etc/init.d/lirc restartirexec 最后手机连接蓝牙模块（BK8000L）并播放音乐，用遥控器的按键进行测试。以上代码只写了五个键（上一曲、下一曲、播放/暂停、增加音量、降低音量），更多功能以后再继续添加。]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>红外</tag>
        <tag>蓝牙</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派红外遥控测试]]></title>
    <url>%2F2016%2F11%2F19%2FRaspberry-IR-Control%2F</url>
    <content type="text"><![CDATA[网上淘到了一个红外接收器（VS1838B）和一个红外遥控器，准备放到树莓派上学习一下红外控制。 本文参考资料：树莓派的红外遥控树莓派作品：红外遥控+2维度步进电机+超声波测距+语音输出【分享】给树莓派安装红外接收管并控制XBMC（连载二）树莓派 红外接收 RPi2 gpio chip not found lirc_rpi3901方案学习、修改遥控码的方法 目标：给树莓派给安装个红外接收管并遥控它 树莓派一个 红外接收器（本文用的是VS1838B） 红外遥控器 继电器一个（可选，也可用LED等） 杜邦线若干条 具体步骤： 1.首先找到VS1838B的引脚定义：按照图示，把红外接收模块用杜邦线连接到树莓派上。2.安装lirc，修改配置文件LIRC (Linux Infrared remote control)是一个linux系统下开源的软件包。这个软件可以让Linux系统接收及发送红外线信号。12sudo apt-get install lircsudo leafpad /etc/lirc/hardware.conf 修改以下几处：1234LIRCD_ATGS=&quot;&quot;DRIVER=&quot;default&quot;DEVICE=&quot;/dev/lirc0&quot;MODULES=&quot;lirc-rpi 3.终端执行1sudo leafpad /etc/modules 添加下面两行到模块配置文件：1234lirc-dev#我把红外接收模块的OUT接口接到了树莓派的GPIO18#因为本例中未用到红外发射模块，所以后面的gpio_out_pin可以不写lirc-rpi gpio_in_pin=18 gpio_out_pin=17 配置完成后，重启一下树莓派，让配置生效。 4.重新开启lirc功能，至此lirc软件就配置完成了。1sudo /etc/init.d/lirc restart 5.红外线接收功能 首先关闭lirc软件，然后执行如下命令： 12sudo /etc/init.d/lirc stopmode2 -d /dev/lirc0 这时候提示 1no such file or directory 经过查看发现 /dev 下面没有 lirc0 这个module，度娘一番后，发现在/boot/config.txt里面把 1dtoverlay=lirc-rpi 取消注释，然后reboot，问题解决。 再次执行 1mode2 -d /dev/lirc0 用红外遥控器，对着接收器按下任意按键，屏幕会打印类似下面的内容，说明红外接收功能正常。 12345space 16300pulse 95space 28794pulse 80space 19395 6.红外编码录制 首先关闭lirc软件，然后查看可用的按键名 12sudo /etc/init.d/lirc stopirrecord -list-namespace 根据我的遥控器，我选择了以下几个按键名并记录下来： 12345678910KEY_CHANNELDOWNKEY_CHANNELUPKEY_CHANNELKEY_PREVIOUSKEY_NEXTKEY_PLAYKEY_VOLUMEDOWNKEY_VOLUMEUPKEY_EQUALKEY_NUMERIC_0 ~ KEY_NUMERIC_9 然后执行红外线编码录制命令1irrecord -d /dev/lirc0 ~/lircd.conf 一直回车，直到看到“Press RETURN now to start recording.”，再回车一次，然后把遥控器上的每一个按键依次按一下，每个按键持续1s以上，每次按键屏幕上都会出现一个“.”。按满两行后屏幕提示“Please enter the name for the next button (press to finish recording)”，然后依次输入想要录制的按键，例如输入：1KEY_PLAY 然后提示“Now hold down button “KEY_LEFT”.”，这时候按下遥控器上的播放按钮，软件会自动记录并跳转回“Please enter the name for the next button (press to finish recording)”，把每一个想录制的按钮全部输入一遍，最后直接回车结束，配置文件就保存了。最后，将录制好的配置文件覆盖lirc软件的相应文件：1sudo cp ~/lircd.conf /etc/lirc/lircd.conf 重启lirc软件，并执行irw命令，测试遥控器与接收模块是否工作正常：12sudo /etc/init.d/lirc startirw 执行完毕后，按下遥控器的任意键，确保能正确输出所按下按钮的名称。例如：123456789100000000000ffa25d 00 KEY_CHANNELDOWN /etc/lirc/lircd.conf0000000000ffa25d 01 KEY_CHANNELDOWN /etc/lirc/lircd.conf0000000000ffa25d 00 KEY_CHANNELUP /etc/lirc/lircd.conf0000000000ffa25d 01 KEY_CHANNELUP /etc/lirc/lircd.conf0000000000ffa25d 00 KEY_CHANNEL /etc/lirc/lircd.conf0000000000ffa25d 01 KEY_CHANNEL /etc/lirc/lircd.conf0000000000ffa25d 00 KEY_PLAY /etc/lirc/lircd.conf0000000000ffa25d 01 KEY_PLAY /etc/lirc/lircd.conf0000000000ffa25d 00 KEY_VOLUMEUP /etc/lirc/lircd.conf0000000000ffa25d 01 KEY_VOLUMEUP /etc/lirc/lircd.conf 7.配置~/.lircrc文件把按键与需要出发的行为进行关联，在~/.lircrc文件中增加如下内容： 12345678910begin prog = irexec button = KEY_PLAY config = sudo python /home/pi/testIR.pyendbegin prog = irexec button = KEY_CHANNEL config = sudo python /home/pi/test_CHANNEL.pyend 本例中使用继电器测试功能，目的是当按下遥控器的Play按钮时，继电器接通，再次按下时，继电器断开。 关于继电器的连接不再赘述，本例中将继电器的IN接口接到了树莓派的GPIO-27，testIR.py的内容如下： 123456789101112131415161718import RPi.GPIO as GPIOPIN = 27GPIO.setmode(GPIO.BCM)GPIO.setwarnings(False)GPIO.setup(PIN, GPIO.IN)GPIO.setup(PIN, GPIO.OUT)# 本例中GPIO的电平与继电器的开合对应情况为：# 低电平--LOW--input值为0--继电器接通# 高电平--HIGH--input值为1--继电器断开if GPIO.input(PIN) == 0: GPIO.output(PIN, GPIO.HIGH)else: GPIO.output(PIN, GPIO.LOW) 将“.lircrc”文件与上述的py文件放到“/home/pi/“目录下，保存。 最后，重启lirc软件并执行“irexec”命令： 12sudo /etc/init.d/lirc restartirexec 当按下遥控器的Play按钮时，继电器接通，再次按下时，继电器断开。表示测试成功。]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>红外</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# WinForm中RichTextBox自动滚动到最新行]]></title>
    <url>%2F2016%2F11%2F08%2FTextBox-AutoScroll%2F</url>
    <content type="text"><![CDATA[C#中一个RichTextBox，当新写入内容时，超过当前显示区域后，没法自动滚动到最低端，不方便查看内容。 【解决方法】在TextBox的TextChanged事件中，添加如下代码： 1234567private void rtbLog_TextChanged(object sender, EventArgs e)&#123; //将光标位置设置到当前内容的末尾 rtbLog.SelectionStart = rtbLog.Text.Length; //滚动到光标位置 rtbLog.ScrollToCaret();&#125; 效果就是所希望的了，当内容变化后，自动滚动到最底端：]]></content>
      <tags>
        <tag>C#</tag>
        <tag>WinForm</tag>
        <tag>TextBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派实现物联网第一步：控制LED]]></title>
    <url>%2F2016%2F09%2F17%2Fraspberry-iot%2F</url>
    <content type="text"><![CDATA[硬件部分 准备材料： 树莓派 面包板（可选） 杜邦线（可选） LED 继电器 LED、继电器等连接到面包板上，继电器连接到树莓派的GPIO11和GPIO13，LED连接到继电器，具体链接方法不再详述； 软件部分 安装FLask(Flask安装教程) 创建led.py，相同目录下创建templates文件夹，里面放一个led.html，代码分别如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import Flask, render_template , requestimport RPi.GPIO as GPIOimport timeGPIO.setmode(GPIO.BOARD)GPIO.setup(11, GPIO.OUT)GPIO.setup(13, GPIO.OUT)GPIO.setup(3, GPIO.OUT)GPIO.setup(5, GPIO.OUT)GPIO.output(11, GPIO.HIGH)GPIO.output(13, GPIO.HIGH)GPIO.output(3, GPIO.LOW)time.sleep(1)GPIO.output(3, GPIO.HIGH)GPIO.output(5, GPIO.LOW)time.sleep(1)GPIO.output(5, GPIO.HIGH)time.sleep(0.1)GPIO.output(5, GPIO.LOW)GPIO.output(3, GPIO.LOW)GPIO.output(13, GPIO.LOW)GPIO.output(11, GPIO.LOW)time.sleep(1)GPIO.output(5, GPIO.HIGH)GPIO.output(3, GPIO.HIGH)GPIO.output(13, GPIO.HIGH)GPIO.output(11, GPIO.HIGH)app = Flask(__name__)a = 'checked'@app.route('/',methods=['GET','POST'])def index(): if request.method =='POST': GPIO.output(5, GPIO.LOW) time.sleep(0.001) GPIO.output(5, GPIO.HIGH) a = request.form["on2"] b = request.form["radio"] if b == 'one': if a == 'on': GPIO.output(11, GPIO.LOW) return render_template('led.html',i = 'ON',a = 'checked') else: GPIO.output(11, GPIO.HIGH) return render_template('led.html',i = 'OFF',a = 'checked') if b == 'two': if a == 'on': GPIO.output(13, GPIO.LOW) return render_template('led.html',j = 'ON',b = 'checked') else: GPIO.output(13, GPIO.HIGH) return render_template('led.html',j = 'OFF',b = 'checked') else: return render_template('led.html',w = 'please choose the botton!') else: GPIO.output(3, GPIO.LOW) time.sleep(0.1) GPIO.output(3, GPIO.HIGH) return render_template('led.html')if __name__ == "__main__": app.run(host='0.0.0.0', port=8888, debug=True) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;led开关&lt;/title&gt; &lt;link rel="shortcut icon" href="favicon.ico"&gt; &lt;/head&gt; &lt;style&gt; .aa&#123; fontcolor:FOO; &#125; &lt;/style&gt; &lt;body&gt; &lt;center&gt; &lt;h1&gt;led控制&lt;/h1&gt; &lt;h3&gt;&#123;&#123;w&#125;&#125;&lt;/h3&gt; &lt;form id="form1" name="form1" method="post" action=""&gt; &lt;p&gt; &lt;input name="radio" type="radio" id="radio" value="one" &#123;&#123;a&#125;&#125;="&#123;&#123;a&#125;&#125;" /&gt; &lt;label for="radio"&gt;&lt;/label&gt; 开关1&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type="radio" name="radio" id="radio" value="two" &#123;&#123;b&#125;&#125;="&#123;&#123;b&#125;&#125;" /&gt; &lt;label for="radio2"&gt;&lt;/label&gt; 开关2 &lt;/p&gt; &lt;p&gt;状态:&#123;&#123;i&#125;&#125; &amp;nbsp;&amp;nbsp;&amp;nbsp; 状态:&#123;&#123;j&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;input style="width:300px; height:75px; background-color: #0F0; font-size:24px; font-family:Verdana, Geneva, sans-serif; font-weight:bold; color:#FFF" type="submit" name="on2" id="on2" value="on" /&gt; &lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt; &lt;input style="width:300px; height:75px; background-color:#F00;font-size:24px; font-family:Verdana, Geneva, sans-serif; font-weight:bold; color:#FFF" type="submit" name="on2" id="on2" value="off" /&gt; &lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 在同一局域网中的其他手机或电脑中输入树莓派的IP地址:8888，即可看到效果： 最后，选择开关1或者开关2，然后点击on或者off，即可看到LED灯会点亮或熄灭。]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>物联网</tag>
        <tag>IOT</tag>
        <tag>LED</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActionBar基础：实现顶部返回按钮]]></title>
    <url>%2F2016%2F06%2F22%2FActionBar-TopBackButton%2F</url>
    <content type="text"><![CDATA[在开写之前需要先引入工程包lib_v7_appcompat，里面为我们提供了ActionBarActivity等许多相关类。 先新建一个activity来继承ActionBarActivity，在里面进行一些基本设置，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * ActionBar基础activity，进行统一的属性设置 * 所有顶部带有actionbar的类都继承此类。 * * @author leetoney * @time 2015年1月31日17:28:00 * */public class BaseActionBarActivity extends ActionBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); // 设置窗口风格为顶部显示Actionbar supportRequestWindowFeature(WindowCompat.FEATURE_ACTION_BAR); ActionBar actionBar = getSupportActionBar(); actionBar.setDisplayShowTitleEnabled(true); actionBar.setDisplayHomeAsUpEnabled(true); // 决定左上角图标的右侧是否有向左的小箭头, true // 有小箭头，并且图标可以点击 actionBar.setDisplayShowHomeEnabled(false); // 使左上角图标是否显示，如果设成false，则没有程序图标，仅仅就个标题， // 否则，显示应用程序图标，对应id为android.R.id.home，对应ActionBar.DISPLAY_SHOW_HOME // force use of overflow menu on devices with menu button // 在actionbar中显示溢出菜单选项 // http://stackoverflow.com/questions/9286822/how-to-force-use-of-overflow-menu-on-devices-with-menu-button try &#123; ViewConfiguration config = ViewConfiguration.get(this); Field menuKeyField = ViewConfiguration.class .getDeclaredField(sHasPermanentMenuKey); if (menuKeyField != null) &#123; menuKeyField.setAccessible(true); menuKeyField.setBoolean(config, false); &#125; &#125; catch (Exception ex) &#123; // Ignore &#125; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home:// 点击返回图标事件 this.finish(); default: return super.onOptionsItemSelected(item); &#125; &#125;&#125; 然后在自己的Activity中继承这个BaseActionBarActivity，这里只设置了标题。123456789public class MainActivity extends BaseActionBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getSupportActionBar().setTitle(返回); &#125;&#125; 效果如图：]]></content>
      <tags>
        <tag>ActionBar</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLite数据库的char,varchar,text,nchar,nvarchar,ntext的区别]]></title>
    <url>%2F2016%2F06%2F15%2Fsqlite-data-type%2F</url>
    <content type="text"><![CDATA[CHAR CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。 VARCHAR 存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么“+1”呢？这一个字节用于保存实际使用了多大的长度。从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。 TEXTtext存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。 NCHAR、NVARCHAR、NTEXT这三种从名字上看比前面三种多了个“N”。它表示存储的是Unicode数据类型的字符。我们知道字符中，英文字符只需要一个字节存储就足够了，但汉字众多，需要两个字节存储，英文与汉字同时存在时容易造成混乱，Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。nchar、nvarchar的长度是在1到4000之间。和char、varchar比较起来，nchar、nvarchar则最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。 1所以一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。 SQLite最大的特点在于其数据类型为无数据类型(typelessness)。这意味着可以保存任何类型的数据到所想要保存的任何表的任何列中，无论这列声明的数据类型是什么。虽然在生成表结构的时候，要声明每个域的数据类型，但SQLite并不做任何检查。开发人员要靠自己的程序来控制输入与读出数据的类型。这里有一个例外，就是当主键为整型值时，如果要插入一个非整型值时会产生异常。 虽然，SQLite允许忽略数据类型，但是，仍然建议在Create Table语句中指定数据类型，因为数据类型有利于增强程序的可读性。另外，虽然在插入或读出数据的时候是不区分类型的，但在比较的时候，不同数据类型是有区别的]]></content>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMD命令提示符改编编码命令]]></title>
    <url>%2F2016%2F06%2F08%2Fchcp%2F</url>
    <content type="text"><![CDATA[CMD中修改字符编码的命令为 chcp，以下为帮助文档：12C:\Windows\system32&gt;help chcp 显示或设置活动代码页编号。 CHCP [nnn] nnn指定代码页编号。 不带参数键入 CHCP 以显示活动代码页编号。 输入:1&gt;chcp 65001 设置编码为UTF-8 输入:1chcp 936 设置编码GBK]]></content>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 自动提示代码设置]]></title>
    <url>%2F2016%2F06%2F06%2FAndroid-Studio-settings%2F</url>
    <content type="text"><![CDATA[Android Studio中默认设置自动提示代码首字母必须严格按照大小写来输入才能提示正确的代码，修改如下设置项，可实现忽略大小写，自动完成代码。 下面的两个时间为代码提示弹出的速度，单位：毫秒。]]></content>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
</search>
